{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-03-01-performance/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"87e60846-6854-54c5-803f-b6bbfd63fb37","excerpt":"Here’s something that might be a bit controversial: I believe that for most software projects, the performance of the language (C#, Golang, PHP, Ruby) doesn’t…","html":"<p>Here’s something that might be a bit controversial: <em>I believe that for most software projects, the performance of the language (C#, Golang, PHP, Ruby) doesn’t matter that much. The reason I am writing this article is that I’ve seen an almost cultlike obsession with various languages and tech stacks, to the point where teams are pushing for a complete rewrite of the application. Even if there isn’t a push for a complete rewrite, there usually is a push for a <em>polyglot</em> microservice setup, which has its own problems.</em></p>\n<p>I believe this is  not warranted for most projects, and I’ll explain why. But first, let’s look at a benchmark showing raw performance for different languages.</p>\n<img src=\"perf.png\" class=\"img\" loading=\"lazy\" />\n<p>As we can see, there’s quite a big difference between, say C and PHP, and if you were to implement a game, or a database engine, the choice of langue would matter <em>a lot</em>. But most projects aren’t relational database engines or games. They are web applications.</p>\n<h3>Inner Loop Optimization</h3>\n<p>A common theme when thinking about optimizing code is the concept of <em>inner loop optimization</em>. Consider the following code:</p>\n<pre class=\"shiki\" style=\"background-color: #292D3E\"><code><span class=\"line\"><span style=\"color: #C792EA\">let</span><span style=\"color: #A6ACCD\"> before </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #A6ACCD\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #A6ACCD\"> after </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #A6ACCD\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #A6ACCD\"> inner </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #A6ACCD\"> </span><span style=\"color: #F78C6C\">0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #89DDFF; font-style: italic\">for</span><span style=\"color: #A6ACCD\"> (</span><span style=\"color: #C792EA\">let</span><span style=\"color: #A6ACCD\"> i </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #A6ACCD\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #A6ACCD\"> i </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #A6ACCD\"> </span><span style=\"color: #F78C6C\">100</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #A6ACCD\"> i</span><span style=\"color: #89DDFF\">++</span><span style=\"color: #A6ACCD\">) </span><span style=\"color: #89DDFF\">{</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">  </span><span style=\"color: #A6ACCD\">before</span><span style=\"color: #89DDFF\">++</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">  </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">  </span><span style=\"color: #89DDFF; font-style: italic\">for</span><span style=\"color: #F07178\">(</span><span style=\"color: #C792EA\">let</span><span style=\"color: #F07178\"> </span><span style=\"color: #A6ACCD\">j</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #F07178\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #F07178\"> </span><span style=\"color: #A6ACCD\">j</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #F07178\"> </span><span style=\"color: #F78C6C\">100</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #F07178\"> </span><span style=\"color: #A6ACCD\">j</span><span style=\"color: #89DDFF\">++</span><span style=\"color: #F07178\">) </span><span style=\"color: #89DDFF\">{</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #A6ACCD\">inner</span><span style=\"color: #89DDFF\">++</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">  </span><span style=\"color: #89DDFF\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F07178\">  </span><span style=\"color: #A6ACCD\">after</span><span style=\"color: #89DDFF\">++</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #A6ACCD\">console</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">log</span><span style=\"color: #A6ACCD\">(</span><span style=\"color: #89DDFF\">{</span><span style=\"color: #A6ACCD\"> before</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #A6ACCD\"> inner</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #A6ACCD\"> after </span><span style=\"color: #89DDFF\">}</span><span style=\"color: #A6ACCD\">)</span></span></code></pre>\n<p>Output:</p>\n<pre class=\"shiki-unknown\"><code>{ before: 100, inner: 10000, outer: 100 }</code></pre>\n<p>As we can see, it’s the inner loop that takes a lot more processor time than the outer loop. When it comes to actual lines of code, the inner loop functionality isn’t necessarily more complex, it’s just being run more and so it takes more processor time.</p>\n<h3>The Classic 3-Tier Architecture</h3>\n<p>This is quite academic, so how does this help is? We need to consider a typical web app using a 3-tier architecture.</p>\n<ol>\n<li>You get an HTTP request.</li>\n<li>Based on this request, you run some business logic that calls some ORM code.</li>\n<li>The ORM code generates SQL, which is run against a relational database.</li>\n<li>The results are then mapped and returned to the caller.</li>\n</ol>\n<p>If you do some profiling, you will find that most of the time is being spent on the database level. Operations such as mapping query results aren’t that computationally expensive.</p>\n<p>Let’s consider a product page where users can filter and order based on categories such. Sorting and joins can abe expensive operations, and if indexes are not used properly, this can result in full table scans and even sorting done in temp tables.</p>\n<img src=\"app.png\" class=\"img\" loading=\"lazy\" />\n<p>ORM performance does matter, however. Here is an interesting graph comparing the performance of different ORMs available for Node.js.</p>\n<img src=\"performance.png\" class=\"img\" loading=\"lazy\" />\n<p>As you can see, yes, performance varies between them quite significantly, but then you have to ask yourself: can I simply scale up my database and are those costs worth it?</p>\n<h3>Mitigating Performance Issues</h3>\n<p>Since most performance bottlenecks happen at the database level, understanding the execution plan your ORM generates goes a long way. And when it comes to queries, joins and sorts have a big performance impact.</p>\n<p>But there is a simpler way to mitigate performance issues: move code to the client.</p>","frontmatter":{"title":"Language Performance Doesn't Matter (Most Of The Time)","date":"March 06, 2024","description":"Here's something that might be a bit controversial: I believe that for most software projects, the performance of the language (C#, Golang) doesn't matter that much. The reason I am writing this article is that I've seen an almost cultlike obsession with various languages and tech stacks, to the point where teams are pushing for a complete rewrite of the application. I believe this is  not warranted for most projects. ","image":"cucumber.jpg","cells":null}},"previous":{"fields":{"slug":"/2024-01-06-modules/"},"frontmatter":{"title":"Should I Pre-Decouple Modules In My Modular Monolith?"}},"next":{"fields":{"slug":"/2024-01-06-modules/"},"frontmatter":{"title":"Should I Pre-Decouple Modules In My Modular Monolith?"}}},"pageContext":{"id":"87e60846-6854-54c5-803f-b6bbfd63fb37"}},"staticQueryHashes":[]}