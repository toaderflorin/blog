{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-01-06-modules/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"2334c24a-7619-5e39-a48b-387e6cbd5ada","excerpt":"First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant…","html":"<p>First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant cost associated with maintaining, deploying and hosting multiple microservices.</p>\n<p>Let’s also look at some microservice tenets:</p>\n<ol>\n<li>Microservices need to own their own data, which means you need a database for each.</li>\n<li>Instead of synchronous communication, you usually use message based communication to ensure decoupling.</li>\n</ol>\n<p>So what does this mean?</p>\n<ol>\n<li>We lose FK constraints, and data integrity related to them.</li>\n<li>Joins across data sources can be tricky.</li>\n<li>Distributed transactions can also be tricky.</li>\n<li>We lose some data normalization (for example, catalog data will probably have to be replicated).</li>\n</ol>\n<p>What is the alternative? Well, writing a monolith. Monoliths in themselves aren’t bad—actually, the term monolith refers to a unit of deployment, and in fact most projects use a monolithic architecture. You can even have a distributed monolith because if the dependencies between microservices are as such that you need to deploy multiple of them at the same time. The only potential problem arises if, at some later point, we want to move to a microservice architecture, those FK constraints will pose a problem. What would be a possible approach? Create a monolith with predefined modules and enforce strict domain boundaries.</p>\n<img src=\"modules2.jpg\" class=\"img\" />\n<p>We would aim for something like this.</p>\n<h2>A Case Study</h2>\n<p>Let’s define a set of spec for an application.</p>\n<p><code>We want to build an online shopping platform where multiple vendors can sell products. Multiple venders can sell the same product (defined by SKU). We would have system admins, vender admins and regular users.</code></p>\n<p>Well start by defining a set of entities:</p>\n<ul>\n<li><em>Product</em></li>\n<li><em>ProductCategory</em></li>\n<li><em>User</em></li>\n<li><em>UserAddress</em></li>\n<li><em>ProductReview</em></li>\n<li><em>UserAddress</em></li>\n<li><em>Vendor</em></li>\n</ul>\n<p>Let’s try to sketch a database schema.</p>\n<img src=\"first.png\" class=\"img\" />\n<p>OK, that was the first draft. Now, let’s do a mental exercise. Let’s think what would be needed in order to break this monolith. We would need to identify a set of domain boundaries, which would correspond to the individual microservices. We won’t actually create microservices, but we will look at what we need to do for our code to be <em>splittable</em>, so let’s move things around.</p>\n<img src=\"middle.png\" class=\"img\" />\n<p>OK, this looks cleaner. As we see, we have created groups of related objects, grouped around users, products, and vendors. They would need to correspond to individual modules / microservices. We can now define a few microservices:</p>\n<ul>\n<li><em>Authentication</em>, related to users.</li>\n<li>Search and product details.</li>\n<li>Payment.</li>\n<li>Catalog and search, related to products.</li>\n</ul>\n<p>In order to separate them into separate modules, we would need to remove the FK constraints. Of course, the question becomes then, how would they communicate. My approach is to use unique domain properties such as the user id, or some company tax code. This is what we will do here.</p>\n<img src=\"final.png\" class=\"img\" />\n<p>That is exactly what we’ve done. And we’ve also removed the permission tables, and we’ll use string keys instead, for example, <code>ADMIN</code>, <code>VENDOR</code>, <code>CUSTOMER</code>. The permission level would come from the user session (as claims).</p>\n<h3>Some Thoughts On Module Communication</h3>\n<p>Decoupling your data model won’t achive anything if individual services in your app are coupled (call one another directly). We know that in the microservice world, direct calls are a no-no. So in order for our microservices to be decoupled, we would need to also decouple our service layer, not just data layer.</p>\n<p>One approach to communication would be to use a message bus. Since your client application will probably make use of push notifications, you’ll use messeging anyway, in conjuction with module communication. This is called <em>coreography</em>. The other approach is to use <em>orhestration</em>, which is usually done on the client, because as I’ve mentioned, we want to avoid direct synchronous calls between microservices.</p>\n<p>Let’s assume we have a Payment service, and it needs to synchronize with the Catalog service. Let’s describe the flow:</p>\n<ol>\n<li>When the user initiates a payment, the product needs to be reserved in the Catalog service.</li>\n<li>This will in turn send a message acknowledging that the product is indeed reserved, so that if another customer tries to place an order, it will manage the stock levels appropriately.</li>\n<li>Once this worked, payment processing will begin.</li>\n<li>If payment succeeds, another message will be sent to the Catalog service, and stocks will be decreased by one.</li>\n<li>Otherwise, the reserved status will be removed.</li>\n</ol>\n<p>The client can also do orchestration and call these steps in order, but this isn’t recommended for business logic flows, especially not for business flows. We’ve just described a distributed transaction.</p>\n<p>There are several ways to do distributed transactions.</p>\n<ol>\n<li>Three phase commits.</li>\n<li>Two phase commits.</li>\n<li>Sagas.</li>\n<li>Compensating transactions.</li>\n</ol>\n<p>But there will be a special article for that.</p>","frontmatter":{"title":"Should I Pre-Decouple Modules In My Modular Monolith?","date":"January 06, 2024","description":"First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant cost associated with maintaining, deploying, hosting., multiple microservices.Let's also look at some microservice tenets: 1. Microservices need to own their own data, which means you need a database for each. 2. Instead of synchronous communication, you usually use message based communication to ensure decoupling. ","image":"screen.png","cells":2}},"previous":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}},"next":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}}},"pageContext":{"id":"2334c24a-7619-5e39-a48b-387e6cbd5ada"}},"staticQueryHashes":[]}