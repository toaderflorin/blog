{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-01-06-modules/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"2334c24a-7619-5e39-a48b-387e6cbd5ada","excerpt":"First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant…","html":"<p>First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant cost associated with maintaining, deploying, hosting., multiple microservices.</p>\n<p>Let’s also look at some microservice tenets:</p>\n<ol>\n<li>Microservices need to own their own data, which means you need a database for each.</li>\n<li>Instead of synchronous communication, you usually use message based communication to ensure decoupling.</li>\n</ol>\n<p>So what does this mean?:</p>\n<ol>\n<li>We lose FK constraints, and data integrity related to them.</li>\n<li>Joins across data sources can be tricky.</li>\n<li>Distributed transactions can also be tricky.</li>\n<li>We lose some data normalization (for example, catalog data will probably have to be replicated).</li>\n</ol>\n<p>What is the alternative? Well, writing a monolith. Monoliths in themselves aren’t bad—the term monolith refers to a unit of deployment. In fact, most APIs are monoliths. Moreover, you can even have a distributed monolith because if the dependencies between microservices are as such that you need to</p>\n<p>The only potential problem arises if, at some later point, we want to move to a microservice architecture, those FK constraints will pose a problem.\nA Modular Monolith</p>\n<p>What would be a possible approach? Create a monolith with predefined modules and enforce strict domain boundaries.</p>\n<h2>DDD</h2>\n<p>Which is where Domain Driven Design comes to play.</p>\n<p>Domain-driven design (DDD) is a software development approach that focuses on modeling software to align closely with the business domain it represents. It emphasizes a deep understanding of the domain, collaboration between domain experts and developers, and the creation of a shared language to bridge the gap between them.</p>\n<p>Core Principles of DDD:</p>\n<ol>\n<li>Ubiquitous Language: Fostering a shared understanding of the domain’s terminology and concepts among developers and domain experts.</li>\n<li>Modeling the Domain: Creating a comprehensive and detailed model of the domain, capturing its core concepts, rules, and relationships.</li>\n<li>Bounded Contexts: Dividing the domain into smaller, manageable subdomains with well-defined boundaries.</li>\n</ol>\n<p>Let’s say we have an online store that sells mugs. We need to support recommendations etc. We will also have a back office website where users can log in, add / update prices, etc.</p>\n<h2>A Case Study</h2>\n<p>Let’s define a bunch of products:</p>\n<ul>\n<li><em>Product</em></li>\n<li><em>ProductCategory</em></li>\n<li><em>User</em></li>\n<li><em>ProductReview</em></li>\n<li><em>UserAddress</em></li>\n</ul>\n<p>So far, so good. It goes as follows:</p>\n<p>We’re keeping it simple. We need to look at where the boundaries intersect. Admins can add items of the catalog.</p>\n<p>The module search will intersect with login, because we are using the user id. The</p>\n<img src=\"schema.png\" class=\"img\" />\n<h2>Breaking The Monolith</h2>\n<p>Let’s do a mental exercise. Let’s think what would be needed in order to break this monolith. We would need to identify a set of domain boundaries and</p>\n<ul>\n<li>Logging in.</li>\n<li>Search and product details.</li>\n<li>Payment.</li>\n<li>Catalog.</li>\n</ul>\n<p>In order to separate them into separate modules, we would need to remove the FK constraints.</p>\n<img src=\"schema.png\" class=\"img\" />\n<p>One idea to achieve coupling is to break the monolith.</p>","frontmatter":{"title":"Modular Monoliths","date":"January 06, 2024","description":"First, when creating a new application, should you start off with a microservice architecture? Well, the prevailing wisdom is no, because there is significant cost associated with maintaining, deploying, hosting., multiple microservices. "}},"previous":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}},"next":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}}},"pageContext":{"id":"2334c24a-7619-5e39-a48b-387e6cbd5ada"}},"staticQueryHashes":[]}