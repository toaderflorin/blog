{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-03-13-data-ownership/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"e4fcb733-39e6-5e08-8c4e-07892e4452e8","excerpt":"When building a monolith, it’s common to not think much about which service accesses which tables, especially when dealing with complex business logic that…","html":"<p>When building a monolith, it’s common to not think much about which service accesses which tables, especially when dealing with complex business logic that needs to conditionally update data based on values of existing data, or if complex data aggregation is needed. To make matters worse, in many projects, not a lot of thought is given to how the database is structured, and it might not actually align well with the business domain (especially if DDD techniques are not followed). Which means it’s very easy to end up with a structure like this:</p>\n<p>What happens in a lot of projects is that your services are trying to create this sort of materialized view by pulling and aggregating data, which means they are coupled indirectly.</p>\n<p>We can clearly see that this breaks encapsulation. We would also want to reach a situation where each service owns its own data, so something like this.</p>\n<p>Keep in mind that the state of the whole application doesn’t have to obey ACID.</p>\n<h3>The Goal Is BASE Not ACID</h3>\n<p>My preferred way of splitting microservices is domain boundary lines. And if you find it hard to split the database schema, then that’s probably an indication that you might not want to split that part of the monolith.</p>\n<p>Most developers will be familiar with ACID constraints of a RDBMS.</p>\n<p>ACID is:</p>","frontmatter":{"title":"Understanding Time Versus Space Performance Tradeoffs","date":"March 19, 2024","description":"Here's something that might be a bit controversial: I believe that for most software projects, the performance of the language (C#, Golang) doesn't matter that much. The reason I am writing this article is that I've seen an almost cultlike obsession with various languages and tech stacks, to the point where teams are pushing for a complete rewrite of the application. I believe this is  not warranted for most projects. ","image":"cucumber.jpg","cells":null}},"previous":{"fields":{"slug":"/2022-05-30-estimations/"},"frontmatter":{"title":"Why It's So Hard To Get Estimations Right?"}},"next":{"fields":{"slug":"/2022-05-30-estimations/"},"frontmatter":{"title":"Why It's So Hard To Get Estimations Right?"}}},"pageContext":{"id":"e4fcb733-39e6-5e08-8c4e-07892e4452e8"}},"staticQueryHashes":[]}