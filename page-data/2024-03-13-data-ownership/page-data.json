{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-03-13-data-ownership/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"e4fcb733-39e6-5e08-8c4e-07892e4452e8","excerpt":"When building a monolith, it’s common to not think much about which service accesses which tables, especially when dealing with complex business logic that…","html":"<p>When building a monolith, it’s common to not think much about which service accesses which tables, especially when dealing with complex business logic that needs to conditionally update data based on values of existing data, or if complex data aggregation is needed. To make matters worse, in many projects, not a lot of thought is given to how the database is structured, and it might not actually align well with the business domain (especially if DDD techniques are not followed). Which means it’s very easy to end up with a structure like this:</p>\n<p>What happens in a lot of projects is that your services are trying to create this sort of materialized view by pulling and aggregating data, which means they are coupled indirectly.</p>\n<p>We can clearly see that this breaks encapsulation. We would also want to reach a situation where each service owns its own data, so something like this.</p>\n<p>Keep in mind that the state of the whole application doesn’t have to obey ACID.</p>\n<h2>The Goal Is BASE Not ACID</h2>\n<p>My preferred way of splitting microservices is domain boundary lines. And if you find it hard to split the database schema, then that’s probably an indication that you might not want to split that part of the monolith.</p>\n<p>The goal around consistency is BASe.</p>\n<p>Most developers will be familiar with ACID constraints of a RDBMS.</p>\n<p>ACID is:</p>\n<ul>\n<li>\n<p><strong>Atomicity</strong> ensures that a transaction is treated as a single unit of work. Either all the operations within the transaction are successfully completed, or none of them are. In other words, a transaction cannot be partially completed; it must be executed in its entirety or not at all. If any part of the transaction fails, the entire transaction is rolled back.</p>\n</li>\n<li>\n<p><strong>Consistency</strong> ensures that the database remains in a consistent state before and after the transaction. This means that transactions must preserve the integrity constraints, data validation rules, and relationships defined in the database schema. For example, if a transaction violates a unique key constraint or a foreign key constraint, it will be aborted to maintain the consistency of the database.</p>\n</li>\n<li>\n<p><strong>Isolation</strong> ensures transactions operate in isolation from each other and even if multiple transactions are executing concurrently, the result should be as if they were executed serially, one after the other. This isolation property prevents interference between transactions and ensures data integrity.</p>\n</li>\n<li>\n<p><strong>Durability</strong> means that once a transaction is committed, its changes are permanent and survive system failures such as power outages or crashes. The changes made by a committed transaction are stored in non-volatile storage (such as disk) and remain intact even if the system fails.</p>\n</li>\n</ul>\n<p>But decoupling your database means you lose all FK integrity so new you need something else. Distributed architectures rely heavily on eventual consistency as a trade-off for better operational architecture characteristics such as performance, scalability, elasticity, fault tolerance, and availability. While there are numerous ways to achieve eventual consistency between data sources and systems, the three main patterns in use today are the background synchronization pattern, orchestrated request-based pattern, and the event-based pattern.</p>\n<p>So we require something else, which is BASE. BASE means:</p>\n<ul>\n<li>\n<p><strong>Basically Available</strong> means that the system should remain operational and responsive, even in the face of failures. It prioritizes availability over consistency. In other words, the system might return slightly outdated or inconsistent data during certain operations, but it ensures that the system remains accessible and operational.</p>\n</li>\n<li>\n<p><strong>Soft state</strong> refers to the idea that the state of the system may change over time, even without input. Unlike in ACID systems, where the state is always consistent and deterministic, in BASE systems, the state might be transient or mutable. This allows for more flexible and scalable designs, particularly in distributed systems where maintaining strong consistency across all nodes can be challenging.</p>\n</li>\n<li>\n<p><strong>Eventually consistency</strong> means that the system will eventually reach a consistent state after a period of time, given no further input. Unlike the immediate consistency guaranteed by ACID transactions, eventual consistency allows for temporary inconsistencies between different replicas or partitions of data. Over time, through mechanisms like gossip protocols, reconciliation, or background processes, these inconsistencies are resolved, and the system converges to a consistent state.</p>\n</li>\n</ul>\n<p>So as we can see, the constraints are much lower. Let’s look at some patterns for inter service communication.</p>\n<h2>Interservice Communication Pattern</h2>\n<p>The simplest form of microservice communication is for one microservice to call another one directly. The main advantage of this approach is simplicity, but there are quite a few drawbacks.</p>\n<ul>\n<li>\n<p><strong>Tight coupling</strong>. If service A depends on service B, any schema change in the response will affect it. Consider that a central tenet of microservices is being able to individually develop and deploy them, this form of tight coupling can cause problems.</p>\n</li>\n<li>\n<p><strong>Scalability issues</strong>. A benefit of independent microservices is they can also be scaled independently. But if a service depends on another service, that service can become a performance bottleneck.</p>\n</li>\n<li>\n<p><strong>Error handling</strong>. The 3rd party service might have crashed, which in turn takes down the services using it.</p>\n</li>\n</ul>\n<p>So let’s look at a way around these.</p>\n<h3>Data Duplication Pattern</h3>\n<p>On order to avoid direct calls between microservices, we can duplicate data. In our above example, the reports service would store its own user summary table in its own database. We would use a</p>\n<p>The main drawback of this is async code is harder to maintain and to understand that synchronous code.</p>","frontmatter":{"title":"Service Data Ownership Is Hard","date":"March 19, 2024","description":"Here's something that might be a bit controversial: I believe that for most software projects, the performance of the language (C#, Golang) doesn't matter that much. The reason I am writing this article is that I've seen an almost cultlike obsession with various languages and tech stacks, to the point where teams are pushing for a complete rewrite of the application. I believe this is  not warranted for most projects. ","image":"cucumber.jpg","cells":null}},"previous":{"fields":{"slug":"/2022-05-30-estimations/"},"frontmatter":{"title":"Why It's So Hard To Get Estimations Right?"}},"next":{"fields":{"slug":"/2022-05-30-estimations/"},"frontmatter":{"title":"Why It's So Hard To Get Estimations Right?"}}},"pageContext":{"id":"e4fcb733-39e6-5e08-8c4e-07892e4452e8"}},"staticQueryHashes":[]}