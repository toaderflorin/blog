{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-10-07-microfrontends/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"244aafb8-3ee5-5169-8e06-52f109a3eb6f","excerpt":"A common theme on the blog is the practicality of approaches (and avoiding development dogma). For example,  Elm is a great technology stack. Still, it probably…","html":"<p>A common theme on the blog is the practicality of approaches (and avoiding development dogma). For example,  Elm is a great technology stack. Still, it probably won’t be on most companies’ adoption lists because technologies like React or Angular are much more popular, and it’s easier to find developers. It’s also much more likely that those technologies will be supported in the future. Likewise, even though microservices are very popular, most projects won’t start out using a microservice architecture.</p>\n<h3>The Hybrid Monolith / Microservice Approach</h3>\n<p>A typical pattern encountered in the wild is the hybrid monolith + satellite microservices approach. This usually occurs something like this:</p>\n<ol>\n<li>A company starts out with a new product, and even though care is taken to split the app into modules, there are usually dependencies between modules - for example, code that hits the same database tables.</li>\n<li>A decision is taken to move to a microservice architecture as the product team grows.</li>\n<li>The team attempts some refactoring and isolates some parts of the monolith into individual microservices.</li>\n<li>New functionality will be developed as new microservices.</li>\n</ol>\n<p>For example, a very simple schematic for an online store might look like this:</p>\n<img src=\"satelite.svg\" class=\"img\" />\n<p>A common problem with breaking up modules into microservices is transactions, because even if individual pieces of code from various modules don’t call each other direcetly, they can still share data and trigger transactions in the database. And with microservices, transactions become distributed. And distributed transactions are hard.</p>\n<h3>Microfrontends</h3>\n<p>Microfontends, as their name suggests, are the front-end equivalent of microservices.</p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/BuRB3djraeM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>Dan Abramov (of Redux fame) famously said he doesn’t understand them. He also said that they can be replaced with a sound component system.</p>\n<img src=\"dan.png\" class=\"img\" />\n<p>One could, of course, point out that microservices can be replaced with a sound module system for a backend API that doesn’t allow us to deploy the modules individually very quickly, nor is interoperability between different technologies easy.</p>\n<p>Polyglot programming is touted as one of the advantages of microservices, but just because you can do something doesn’t mean you should. You almost certainly don’t want to start out with microservices written in distinct languages, but what’s great about them is you can integrate existing services written in different languages, which might occur as a result of acquiring another company (for example).</p>\n<h3>A Case Study</h3>\n<p>Imagine an application that was built with the legacy AngularJS API from Google. For any company that has invested years of development in a product built on it, the canceling of development on Agular by Google was terrible news. Working on discontinued tech isn’t great because browser support etc. is no longer provided. Patterns evolve, and it’s harder and harder to find developers willing to work on them. Let’s now say that the company decides to continue new development using React because it is the most popular technology out there and to use a bridge such as react2angular to bridge the connection between the apps. A potential approach would work as follows:</p>\n<p>The core is in AnguarJS.</p>\n<img src=\"comparison.svg\" class=\"img\" />\n<p>New routes/pages in the application are written in React and plugged in the. This is hardly ideal because Angular and React use vastly different architectural approaches.</p>\n<ul>\n<li>AngularJS uses two way databing.</li>\n<li>React/Redux uses a single directional flow, with prop drilling and callbacks for passing the information back.</li>\n</ul>\n<p>The approach simply isn’t very good, so we’ll need another approach.</p>\n<h3>The Strangler Fig Pattern</h3>\n<p>This pattern was introduced by Martin Fowler and is an analogy for a type of plant that begins life as a vine growing alongside an older tree and as the vine grows, it spreads to completely consume and ultimately replace the host tree, leaving a new, strangler fig tree in its place.</p>\n<p>In the context of microservices, we begin by adding a gateway on top of the monolith, and then gradually splitting off pieces from the monolith. The gateway acts as an abstraction layer and takes care of routing the request of the client to the appropriate functionality route. Independent modules care be easily abstracted away, but what we care is shared state / transactions. Since it’s recommended that microservices own their own data, we need to switch to distributed transactions such as sagas. A message broker is crucial in decoupling microservices.</p>\n<p>Completely replacing a complex system can be a huge undertaking. Often, you will need a gradual migration to a new system, while keeping the old system to handle features that haven’t been migrated yet. However, running two separate versions of an application means that clients have to know where particular features are located. Every time a feature or service is migrated, clients need to be updated to point to the new location.</p>\n<p>Decoupling frontend applications isn’t that much different. Let’s analyze a very poopular solution, SingleSPA. SingleSPA acts like the frontend equivalent of a gateway — it’s the outer shell that loads the various frontend bundles. The various microfrontends run as independent applications - the only way to make them communicate is through shared cookies / storage or push notifications.</p>\n<p>While SingleSPA provides top level routing, each of the individual frontends will also have their own routing system. The MFEs are also isolated and will have their own reactivity system etc. A good practice to follow is to render based on route.</p>\n<p>A central tenet of distributed systems is each piece needs to own its own data. Also, with web applications (they don’t have to be distributed), it’s better that each route in a client application loads the data it needs based on the URL parameters, than to rely on global state and prefetched data. This makes deep linking and refreshing pages much easier to implement — refreshing is simply a matter of updating the page route with different parameters. Since each page / route loads its data, they can be easily split into independent MFEs. With AngularJS apps, that is usually the case.</p>\n<p>Note: global state objects such as the one introduced by Redux makes splitting React/Redux apps into smaller MFEs quite problematic. Before moving various pieces of the application into individual MFEs, it is recommended the frontend is decoupled from the global app state.</p>\n<p>MVVM applications like KnockoutJS are easy to split because components usually have their own state. Angular’s services makes it harder to do this, for example, but they can be copied between MFEs, if needed.</p>\n<h3>The Problem with Redux</h3>\n<p>Since Redux state is global, technically each component can both access and modify each piece of state. In the worst case scenario, we could have something like this:</p>\n<p>Redux is supposed to be your <em>view model</em>, NOT domain model. The domain model resides on the server in the database.</p>\n<p>So this is correct:</p>\n<p>This isn’t.</p>\n<p>Unfortunately, if your application looks like the second, you are going to have a hard time breaking it up.</p>\n<p>In reality, most</p>\n<p>(next) Azure Hyprescale Named instances are a game changer</p>","frontmatter":{"title":"Breaking The Frontend Monolith","date":"October 10, 2023","description":"When Google announced that it would be rebooting AngularJS and that Angular 2.0 would be effectively a new framework, a lot of companies with products built on the old version were put in a difficult situation of having to either restart building their product from scratch or continue with a deprecated technology or you some kind of hybrid solution. Continuing to build on a deprecated technology is obviously risky. As time passes, there are no more updates to the library, and finding developers willing to work on it becomes harder and harder, so this isn't really an option. ","image":null}},"previous":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}},"next":{"fields":{"slug":"/2022-02-27-cqrs/"},"frontmatter":{"title":"You Probably Don't Need CQRS"}}},"pageContext":{"id":"244aafb8-3ee5-5169-8e06-52f109a3eb6f"}},"staticQueryHashes":[]}