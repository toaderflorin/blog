{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-03-01-tradeoff/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"3d440155-cf08-53da-a1c0-e3e5050dc514","excerpt":"As developers, we use hash tables on a daily basis (directly or indirectly) because they are ubiquitous in software. Yet if you ask most developers, they would…","html":"<p>As developers, we use hash tables on a daily basis (directly or indirectly) because they are ubiquitous in software. Yet if you ask most developers, they would not be able to explain how they work, so why not provide a simple explanation here?</p>\n<p>Let’s assume you have a list of users, and you want to show the details for a user based on username. Since lists are usually implemented as linked lists under the hood, finding the element means iterating through the whole list, which is an O(n) operation. This is different from\naccessing an array, which can be done by index. This is an O(1) operation. So what if we wanted to have something similar? We would need to store the usernames in an array under the hood, and somehow “convert” the username string to an index.</p>\n<p>f(string): number</p>\n<p>We can come up with a checksum function, for example. This isn’t a great way to do it, but it will do, as an example.</p>\n<p>So what we do is we calculate the index based on the string. You will notice that:</p>\n<ol>\n<li>There will be a lot of empty space in the array.</li>\n<li>There can be collisions, meaning that two different strings can have the same numeric index.</li>\n</ol>\n<p>So what we do is instead of just storing a user at each point in an array, we can store a list of users with the same checksum (called a bucket). So when we access an element, we actually iterate through the list and check against the username. Normally you shouldn’t have more than a few items in the list anyway. The bigger the array used, the smaller the chance of a collision, but obviously the more memory will be needed.</p>\n<p><em>In ideal circumstances, the size of the array would be infinite, and access time would be O(1), but that’s not realistic. What we have is a tradeoff between access time and space.</em></p>\n<h3>Caching / Materialized Views</h3>\n<p>The simplest example of space / execution</p>\n<p>Another example of a space / execution time tradeoff are materialized views. Imagine you have a complex query that is computationally expensive. Most applications are more read intensive than they are read intensive, and the ratio is usually something like 100:1. This means we could precalculate the result of some queries and it would be worth it.</p>\n<p>An interesting thing about materialized queries is they denormalize the data, which also means data duplication in itself. Let’s consider a very simple example, we have users and each user can define a set of</p>\n<p>A cross join between them</p>\n<h3>Sharded Databases Also Require Data Duplication</h3>\n<p>Another example of a space / execution time tradeoff are materialized views. Imagine you have a complex query that is computationally expensive. Most applications are more read intensive than they are read intensive, and the ratio is typically something like 100:1. This means we could precalculate the result of some queries and it would be worth it.</p>\n<p>Data duplication</p>","frontmatter":{"title":"Understanding Time Versus Space Tradeoffs","date":"March 06, 2024","description":"Here's something that might be a bit controversial: I believe that for most software projects, the performance of the language (C#, Golang) doesn't matter that much. The reason I am writing this article is that I've seen an almost cultlike obsession with various languages and tech stacks, to the point where teams are pushing for a complete rewrite of the application. I believe this is  not warranted for most projects. ","image":"cucumber.jpg","cells":null}},"previous":{"fields":{"slug":"/2024-01-06-modules/"},"frontmatter":{"title":"Should I Pre-Decouple Modules In My Modular Monolith?"}},"next":{"fields":{"slug":"/2024-01-06-modules/"},"frontmatter":{"title":"Should I Pre-Decouple Modules In My Modular Monolith?"}}},"pageContext":{"id":"3d440155-cf08-53da-a1c0-e3e5050dc514"}},"staticQueryHashes":[]}